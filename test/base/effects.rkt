#lang racket

(require rackunit/text-ui racket/splicing)
(require rackunit rosette/base/core/effects rosette/lib/roseunit)
(require rosette/base/struct/struct rosette/base/adt/vector rosette/base/adt/box)

(splicing-let ([&x (@box 0)]
               [&y (@box 10)])
  (define-syntax x
    (syntax-id-rules (set!)
      [(set! x v) (@set-box! &x v)]
      [x (@unbox &x)]))
  (define-syntax y
    (syntax-id-rules (set!)
      [(set! y v) (@set-box! &y v)]
      [y (@unbox &y)])))

(define (x-set! val) (set! x val))
(define (y-set! val) (set! y val))

(define minimized
  (test-suite+ 
   "Minimized tests for rosette/base/speculate.rkt"
   
   (let* ([z (@box 10)]
          [z-set! (lambda (val) (@set-box! z val))])
     (let-values ([(o s) (speculate (begin (z-set! 2) (@unbox z)))])
       (check-equal? o 2)
       (check-equal? (@unbox z) 10)
       (s *)
       (check-equal? (@unbox z) 20)
       (s (lambda (c f) f))
       (check-equal? (@unbox z) o)
       ))))

(define tests
  (test-suite+
   "Tests for rosette/base/speculate.rkt"   
 
   (let-values ([(o s) (speculate 1)])
     (check-equal? o 1))
   
   (let-values ([(o s) (speculate (+ x y))])
     (check-equal? o (+ x y)))
   
   (let-values ([(o s) (speculate (begin (set! x 3) x))])
     (check-equal? o 3)
     (check-equal? x 0))
   
   (let-values ([(o s) (speculate (begin (set! x 5) x))])
     (check-equal? o 5)
     (check-equal? x 0)
     (s +)
     (check-equal? x 5)
     (s *)
     (check-equal? x 25)
     (s (lambda (c f) (+ x y)))
     (check-equal? x 35)
     )
   
   (let-values ([(o s) (speculate (let ([tmp x])
                                    (set! x y)
                                    (set! y tmp)))])
     (check-true (void? o))
     (check-equal? x 35)
     (check-equal? y 10)
     (s (lambda (c f) f))
     (check-equal? x 10)
     (check-equal? y 35)
     (s (lambda (c f) c))
     (check-equal? x 10)
     (check-equal? y 35)
     )
   
   (let ([z (@box 10)])
     (let-values ([(o s) (speculate (begin (@set-box! z 2) (@unbox z)))])
       (check-equal? o 2)
       (check-equal? z (@box 10))
       (s *)
       (check-equal? z (@box 20))
       (s (lambda (c f) f))
       (check-equal? z (@box o))
       ))
  
   
   (let ([z (@box 10)])
     (set! x 0)
     (set! y 5)
     (let-values ([(o s) (speculate (let ([tmp x])
                                      (set! x y)
                                      (set! y (@unbox z))
                                      (@set-box! z tmp)))])
       (check-true (void? o))
       (check-equal? x 0)
       (check-equal? y 5)
       (check-equal? z (@box 10))
       (s (lambda (c f) f))
       (check-equal? x 5)
       (check-equal? y 10)
       (check-equal? z (@box 0))))
   
   (let ([z (@box 10)])
     (set! x 0)
     (set! y 5)
     (let-values ([(o s) (speculate (let ([tmp x])
                                      (let-values ([(o-in s-in) 
                                                    (speculate (begin (set! x y)
                                                                      (set! y (@unbox z))
                                                                      (@set-box! z tmp)))])
                                        (list o-in s-in))))])
       (let ([o-in (first o)] [s-in (second o)])
         (check-true (void? o-in))
         (check-equal? x 0)
         (check-equal? y 5)
         (check-equal? z (@box 10))
         (s (lambda (c f) f))
         (check-equal? x 0)
         (check-equal? y 5)
         (check-equal? z (@box 10))
         (s-in (lambda (c f) f))
         (check-equal? x 5)
         (check-equal? y 10)
         (check-equal? z (@box 0)))))
   
     (let* ([z (@box 10)]
            [z-set! (lambda (val) (@set-box! z val))])
       (set! x 0)
       (set! y 5)
     (let-values ([(o s) (speculate (let ([tmp x])
                                      (let-values ([(o-in s-in) 
                                                    (speculate (begin (x-set! y)
                                                                      (y-set! (@unbox z))
                                                                      (z-set! tmp)))])
                                        (list o-in s-in))))])
       (let ([o-in (first o)] [s-in (second o)])
         (check-true (void? o-in))
         (check-equal? x 0)
         (check-equal? y 5)
         (check-equal? z (@box 10))
         (s (lambda (c f) f))
         (check-equal? x 0)
         (check-equal? y 5)
         (check-equal? z (@box 10))
         (s-in (lambda (c f) f))
         (check-equal? x 5)
         (check-equal? y 10)
         (check-equal? z (@box 0)))))
     
    (let* ([z (@box 10)]
           [z-set! (lambda (val) (@set-box! z val))])
      (set! x 0)
      (set! y 5)
      (let-values ([(o s) (speculate (let ([tmp x])
                                       (let-values ([(o-in s-in) 
                                                     (speculate (begin (x-set! y)
                                                                       (y-set! (@unbox z))
                                                                       (z-set! tmp)
                                                                       ))])
                                         (check-true (void? o-in))
                                         (check-equal? x 0)
                                         (check-equal? y 5)
                                         (check-equal? z (@box 10))
                                         (s-in (lambda (c f) (+ 2 f)))
                                         (list o-in s-in))))])
        (let ([o-in (first o)] [s-in (second o)])
          (check-true (void? o-in))
          (check-equal? x 0)
          (check-equal? y 5)
          (check-equal? z (@box 10))
          (s (lambda (c f) f))
          (check-equal? x 7)
          (check-equal? y 12)
          (check-equal? z (@box 2))
          (s-in (lambda (c f) f))
          (check-equal? x 5)
          (check-equal? y 10)
          (check-equal? z (@box 0)))))
    
   (let ([z (@box 10)] 
         [w (@box 5)])
     (set! x -1)
     (set! y -17)
     (let-values ([(o s) (speculate (begin (@set-box! z 2) (@unbox z)))])
       (check-equal? o 2)
       (check-equal? z (@box 10))
       (check-equal? w (@box 5))
       (check-equal? x -1)
       (check-equal? y -17)
       (s *)
       (check-equal? z (@box 20))
       (check-equal? w (@box 5))
       (check-equal? x -1)
       (check-equal? y -17)
       (s (lambda (c f) f))
       (check-equal? z (@box o))
       (check-equal? w (@box 5))
       (check-equal? x -1)
       (check-equal? y -17)
       ))))

(struct pos ([x #:mutable] y))
(define p (pos 0 1))

(define struct-tests
  (test-suite+
   "Tests for struct handling in rosette/base/speculate.rkt"
     
   (let-values ([(o s) (speculate (begin (set-pos-x! p 3) (pos-x p)))])
     (check-equal? o 3)
     (check-equal? (pos-x p) 0)
     (s +)
     (check-equal? (pos-x p) 3)
     (s *)
     (check-equal? (pos-x p) 9)
     (s -)
     (check-equal? (pos-x p) 6))
   
   (set-pos-x! p 0)
   (let-values ([(o s) (speculate (let ([r p]) (set-pos-x! r 3) (pos-x r)))]) ; aliasing
     (check-equal? o 3)
     (check-equal? (pos-x p) 0)
     (s +)
     (check-equal? (pos-x p) 3)
     (s *)
     (check-equal? (pos-x p) 9)
     (s -)
     (check-equal? (pos-x p) 6))
   
   (set-pos-x! p 0)
   (let ([z (@box (pos 1 5))])
     (let-values ([(o-outer s-outer) 
                   (speculate (let ([q p][proc set-pos-x!])
                                (let-values ([(o-inner s-inner) 
                                              (speculate (begin (set-pos-x! q 4)
                                                                (proc (@unbox z) 2)
                                                                (@set-box! z q)))])
                                  (list o-inner s-inner))))])
       (let ([o-inner (first o-outer)] [s-inner (second o-outer)])
         (check-equal? (pos-x p) 0)
         (check-equal? (pos-x (@unbox z)) 1)
         (s-outer +)
         (check-equal? (pos-x p) 0)
         (check-equal? (pos-x (@unbox z)) 1)
         (s-inner (lambda (last final) (if (and (number? last) (number? final)) (+ last final) last)))
         (check-equal? (pos-x p) 4)
         (check-equal? (pos-x (@unbox z)) 3)
         (s-inner (lambda (last final) (if (and (number? last) (number? final)) (* last final) final)))
         (check-equal? (pos-x p) 16)
         (check-equal? (pos-x (@unbox z)) 16)
         (check-equal? z (@box p))))))) 

(define v (make-vector 3 0))

(define vector-tests
  (test-suite+
   "Tests for vector handling in rosette/base/speculate.rkt"
   
   (let-values ([(o s) (speculate (begin (@vector-set! v 2 3) (@vector-ref v 2)))])
     (check-equal? o 3)
     (check-equal? v (make-vector 3 0))
     (s +)
     (check-equal? v (@vector 0 0 3))
     (s *)
     (check-equal? v (@vector 0 0 9))
     (s -)
     (check-equal? v (@vector 0 0 6)))
   
   (@vector-set! v 2 0)
   (let-values ([(o s) (speculate (let ([r v]) (@vector-set! r 1 3) (@vector-ref r 1)))]) ; aliasing
     (check-equal? o 3)
     (check-equal? v (make-vector 3 0))
     (s +)
     (check-equal? v (@vector 0 3 0))
     (s *)
     (check-equal? v (@vector 0 9 0))
     (s -)
     (check-equal? v (@vector 0 6 0)))
   
   (@vector-set! v 1 0)
   (let ([z (@box (@vector 1 3 5 6))])
     (let-values ([(o-outer s-outer) 
                   (speculate (let ([q v][proc @vector-set!])
                                (let-values ([(o-inner s-inner) 
                                              (speculate (begin (@vector-set! q 0 4)
                                                                (proc (@unbox z) 0 2)
                                                                (@set-box! z q)))])
                                  (list o-inner s-inner))))])
       (let ([o-inner (first o-outer)] [s-inner (second o-outer)])
         (check-equal? v (make-vector 3 0))
         (check-equal? z (@box (@vector 1 3 5 6)))
         (s-outer +)
         (check-equal? v (make-vector 3 0))
         (check-equal? z (@box (@vector 1 3 5 6)))
         (s-inner (lambda (last final) (if (and (number? last) (number? final)) (+ last final) last)))
         (check-equal? v (@vector 4 0 0))
         (check-equal? z (@box (@vector 3 3 5 6)))
         (s-inner (lambda (last final) (if (and (number? last) (number? final)) (* last final) final)))
         (check-equal? v (@vector 16 0 0))
         (check-equal? z (@box (@vector 16 0 0)))
         (check-equal? z (@box v)))))
))

(module+ test
  (time (run-tests minimized))
  (time (run-tests tests))
  (time (run-tests struct-tests))
  (time (run-tests vector-tests)))

