#lang racket

(require syntax/parse/define
         "core.rkt"
         (only-in "../base/core/reflect.rkt" symbolics)
         (only-in "../base/core/result.rkt" result-state)
         (only-in "../base/core/bool.rkt" ! vc with-vc vc-assumes vc-asserts vc-true))

(provide solve verify synthesize optimize
         current-solver (rename-out [∃-solve+ solve+]))

(define (pre)
  (define s (vc))
  (list (vc-assumes s) (vc-asserts s)))

(define-syntax-rule (query-vc expr)
  (result-state (with-vc vc-true expr)))

; The (solve expr) query evaluates expr, gathers all  
; assumptions assertions generated during the evaluation, 
; and searches for a model (a binding from symbolic 
; constants to values) that satisfies these assumptions and assertions,
; as well as any assumptions and assertions generated before the
; call to solve. The solve query creates its own vc context, so
; (vc) is unchanged after solve returns.
(define-syntax-rule (solve expr)
  (let ([post (query-vc expr)])
    (∃-solve `(,@(pre) ,(vc-assumes post) ,(vc-asserts post)))))
               

; The (verify expr) query evaluates expr, gathers all 
; assumptions and assertions generated during the evaluation, 
; and searches for a model (a binding from symbolic 
; constants to values) that satisfies violates at least one of
; the assertions generated by expr, while satisfying all the
; assumptions generated by expr as well as the assumptions and
; assertions generated *before* the call to verify. The verify
; query  creates its own vc context, so (vc) is unchanged after
; verify returns.
(define-syntax-rule (verify expr)
  (let ([post (query-vc expr)])
    (∃-solve `(,@(pre) ,(vc-assumes post) ,(! (vc-asserts post))))))

; The (synthesize vars expr) query evaluates the given forms, gathers all  
; assumptions and assertions generated during the evaluation, 
; and searches for a model (a binding from symbolic 
; constants to values) of the formula ∃H. (∀I. pre => post) ∧ (∃I. pre), 
; where I are the given input constants, H are all other symoblic constants,
; post consists of the assertions generated by expr, and pre consists of the
; assumptions generated by expr as well as the assumptions and
; assertions generated *before* the call to synthesize. If the input expression
; generates any assumptions or assertions, these are reflected in the (vc) after
; the synthesize query returns. The assumptions and assertions generated by expr
; are not added to (vc) after synthesize returns.
(define-syntax synthesize 
  (syntax-rules (synthesize)
    [(_ #:forall inputs #:guarantee expr)
     (let ([vars (symbolics inputs)] ; evaluate inputs first to add their spec to (vc)
           [post (query-vc expr)])
       (∃∀-solve vars `(,@(pre) ,(vc-assumes post)) `(,(vc-asserts post))))]
    [(_ inputs expr)
     (synthesize #:forall inputs #:guarantee expr)]))

; The optimize query evaluates the given form, gathers all 
; assumptions and assertions generated during the evaluation, 
; and searches for a model (a binding from symbolic 
; constants to values) that is optimal with respect to the
; given objectives and  that satisfies the generated assumptions
; and assertions, as well as any assumptions and assertions generated
; before the call to optimize. If the opt expressions
; generate any assumptions or assertions, these are reflected in the (vc) after
; the optimize query returns. The assumptions and assertions generated by expr
; are not added to (vc) after optimize returns.
(define-syntax-parser optimize
  [(_ {~and kw {~or* #:minimize #:maximize}} opt #:guarantee expr)
   #'(let ([obj opt]    ; evaluate objective first to add its spec to (vc)
           [post (query-vc expr)])
       (∃-solve `(,@(pre) ,(vc-assumes post) ,(vc-asserts post)) kw obj))]
  [(_ {~and kw1 {~or* #:minimize #:maximize}} opt1
      {~and kw2 {~or* #:minimize #:maximize}} opt2
      #:guarantee expr)
   #'(let ([obj1 opt1]  ; evaluate objectives first to add their spec to (vc)
           [obj2 opt2]
           [post (query-vc expr)])
       (∃-solve `(,@(pre) ,(vc-assumes post) ,(vc-asserts post)) kw1 obj1 kw2 obj2))])
