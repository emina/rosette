#lang racket

(require syntax/stx syntax/kerncase racket/keyword-transform
         (only-in "record.rkt" record-apply! record-source!)
         "../util/syntax.rkt")
(provide symbolic-profile-compile-handler symbolic-profile-rosette-only?)


;; This file implements profiler instrumentation based on the `errortrace/stacktrace` library.
;; Our instrumentation makes two changes to fully-expanded modules:
;;   1. It wraps procedure calls (instances of #%app) with a call to record-apply!
;;   2. It wraps definition forms (define-values, let-values, etc) that define lambdas
;;      with a call to record-source!
;; We need to reimplement errortrace to get (2), since the errortrace library only lets us
;; annotate expression forms.
;; Most code here is copied from errortrace and simplfied to remove features we don't use.


;; If true (the default), we'll only instrument modules whose base language
;; is rosette or rosette/safe. Otherwise we'll instrument every module.
(define symbolic-profile-rosette-only? (make-parameter #t))


;; Misc syntax munging stuff ---------------------------------------------------

(define base-phase
  (variable-reference->module-base-phase (#%variable-reference)))
(define code-insp (variable-reference->module-declaration-inspector
                   (#%variable-reference)))
(define (rearm orig new)
  (syntax-rearm new orig))
(define (disarm stx)
  (syntax-disarm stx code-insp))
(define (id=? id name)
  (and (identifier? id) (equal? (syntax-e id) name)))

;; Path management -------------------------------------------------------------

;; We shouldn't instrument procedure calls to Rosette functions
;; that aren't actually exported by Rosette
(define (should-instrument-path? path)
  (define the-path (path-string->string path))
  (or (not the-path)
      (not (or (string-contains? the-path "rosette/base/form/module.rkt")
               (string-contains? the-path "rosette/base/form/control.rkt")
               (string-contains? the-path "rosette/query/form.rkt")
               (string-contains? the-path "rosette/query/core.rkt")))))



;; Instrumentation for procedure applications ----------------------------------

;; This is a giant hack to detect applications of keyword procedures.
;; Macro expansion of the definition and application of a keyword procedure
;; hides the information we need, with no simple way to get it back
;; (the "is original?" syntax property we add below is not preserved).
;; So we have this heuristic to try to detect applications of keyword procedures
;; that originated in a file we're instrumenting.
(define original-files (mutable-set))
(define (is-keyword-procedure-application? expr head)
  ; Here are the rules:
  ; - if `head` has an alias or converted args property, it must be a kw procedure application.
  ;   return #t iff the source of that property is not in rosette/query/form.rkt.
  ; - otherwise, it's a kw procedure application if the source of the expr is kw.rkt.
  ;   - if `head` has a source, it must be an original file
  ;   - if `head` has no source, assume it's a kw procedure application unless it's the
  ;     `unpack` procedure generated by kw.rkt
  (define source-property
    (or (syntax-procedure-alias-property head)
        (syntax-procedure-converted-arguments-property head)))
  (cond
    [source-property
     (define src (syntax-source (if (pair? source-property) (car source-property) source-property)))
     (should-instrument-path? src)]
    [(and (syntax-source expr)
          (string-contains? (path-string->string (syntax-source expr))
                            "racket/private/kw.rkt"))
     (if (syntax-source head)
         (set-member? original-files (syntax-source head))
         (let ([s (syntax->datum head)])
           (or (not (symbol? s))
               (not (string-prefix? (symbol->string s) "unpack")))))]
    [else
     #f]))


;; Produce a list of syntax objects that quote each item in the input list
(define (quote-list lst phase)
  (with-syntax ([qt (syntax-shift-phase-level #'quote (- phase base-phase))])
    (for/list ([x lst]) (quasisyntax (qt #,x)))))


;; Wrap an application (passed as the syntax list `rest`, without the #%app first element)
;; with a call to the record-apply! instrumentation
(define (instrument-application stx rest phase)
  (with-syntax ([record-apply! record-apply!]
                [app (syntax-shift-phase-level #'#%plain-app (- phase base-phase))]
                [qt (syntax-shift-phase-level #'quote (- phase base-phase))]
                [lst (syntax-shift-phase-level #'list (- phase base-phase))])
    (quasisyntax (app (qt record-apply!) (app lst #,@(quote-list (syntax->readable-location stx) phase)) #,@rest))))


  
;; Instrumentation for let bindings and define-values --------------------------

;; Rewrite a definition of the form
;;  (let (names rhs) body)
;; to record source instrumentation when the rhs is a plain-lambda.
(define (instrument-binding phase names rhs [lv #'let-values])
  (let* ([rhs* (annotate rhs phase)]
         [rhs** (syntax-case rhs* (#%plain-lambda)
                  [(#%plain-lambda . rest)
                   (for/or ([n (syntax->list names)]) (is-original? n))
                   (with-syntax ([record-source! record-source!]
                                 [app (syntax-shift-phase-level #'#%plain-app (- phase base-phase))]
                                 [qt (syntax-shift-phase-level #'quote (- phase base-phase))]
                                 [lst (syntax-shift-phase-level #'list (- phase base-phase))]
                                 [lv (syntax-shift-phase-level lv (- phase base-phase))]
                                 [values (syntax-shift-phase-level #'values (- phase base-phase))])
                     (quasisyntax
                      (lv ([#,names #,rhs*])
                          (app (qt record-source!) (app lst #,@(syntax->list names)) (app lst #,@(quote-list (syntax->readable-location rhs*) phase)))
                          #,(if (one-name names)  ; optimization for single return value
                                (car (syntax-e names))
                                #`(app values #,@(syntax->list names))))))]
                  [_ rhs*])])
    (cons rhs rhs**)))



;; Core instrumentation procedure ----------------------------------------------

;; Recursively annotate a lambda expression
(define (annotate-lambda expr clause bodys-stx phase)
  (let* ([bodys (stx->list bodys-stx)]
         [bodyl (map (lambda (e) (annotate e phase)) bodys)])
    (rebuild clause (map cons bodys bodyl))))

;; Recursively annotate a sequence
(define (annotate-seq expr bodys-stx annotate phase)
    (let* ([bodys (syntax->list bodys-stx)]
           [bodyl (map (lambda (b) (annotate b phase)) bodys)])
      (rebuild expr (map cons bodys bodyl))))

;; Recursively annotate a submodule
(define (annotate-module expr disarmed-expr phase)
  (define shifted-disarmed-expr
    (syntax-shift-phase-level disarmed-expr (- phase)))
  (syntax-case shifted-disarmed-expr ()
    [(mod name init-import mb)
     (syntax-case (disarm #'mb) ()
       [(__plain-module-begin body ...)
        ;; Just wrap body expressions
        (let ([bodys (syntax->list (syntax (body ...)))])
          (let ([bodyl (map (lambda (b) (annotate-top b 0)) bodys)]
                [mb #'mb])
            (rearm
             expr
             (syntax-shift-phase-level
              (rebuild
               shifted-disarmed-expr
               (list (cons
                      mb
                      (rearm
                       mb
                       (rebuild mb (map cons bodys bodyl))))))
              phase))))])]))

;; Return the first element in a list of syntax objects if the list has length 1
(define (one-name names-stx)
    (let ([l (syntax->list names-stx)])
      (and (pair? l)
           (null? (cdr l))
           (car l))))


;; Create a top-level annotation procedure that recurses down the syntax of a
;; fully expanded module.
;; This form is copied from errortrace, with the features we don't use removed,
;; and with additional annotation for let bindings and top level define-values.
(define (make-annotate top?)
  (lambda (expr phase)
    (define disarmed-expr (disarm expr))
    (kernel-syntax-case/phase disarmed-expr phase
      [_
       (identifier? expr)
       expr]
      [(#%top . id)
       expr]
      [(#%variable-reference . _)
       expr]
      [(define-values names rhs)
       top?
       (let* ([rhsl (instrument-binding phase #'names #'rhs #'letrec-values)])
         (rebuild disarmed-expr (list rhsl)))]
         
      [(begin . exprs)
       top?
       (rearm
        expr
        (annotate-seq disarmed-expr
                      (syntax exprs)
                      annotate-top phase))]
      [(define-syntaxes (name ...) rhs)
       top?
       (let* ([marked (annotate (syntax rhs) (add1 phase))]
              ;; cover at THIS phase, since thats where its bound
              [rebuilt (rebuild disarmed-expr (list (cons #'rhs marked)))])
         (rearm expr rebuilt))]
      [(begin-for-syntax . exprs)
       top?
       (rearm
        expr
        (annotate-seq disarmed-expr
                      (syntax exprs)
                      annotate-top 
                      (add1 phase)))]

      [(module name init-import mb)
       (annotate-module expr disarmed-expr 0)]
      [(module* name init-import mb)
       (annotate-module expr disarmed-expr (if (syntax-e #'init-import) 0 phase))]
         
      [(#%expression e)
       (rearm expr #`(#%expression #,(annotate (syntax e) phase)))]
         
      ;; No way to wrap
      [(#%require i ...) expr]
      ;; No error possible (and no way to wrap)
      [(#%provide i ...) expr]
      [(#%declare i ...) expr]
         
      ;; No error possible
      [(quote _)
       expr]
      [(quote-syntax . _)
       expr]
         
      ;; Wrap body, also a profile point
      [(#%plain-lambda args . body)
       (rearm
        expr
        (keep-lambda-properties
         expr
         (annotate-lambda expr disarmed-expr (syntax body)
                          phase)))]
      [(case-lambda clause ...)
       (with-syntax ([([args . body] ...)
                      (syntax (clause ...))])
         (let* ([clauses (syntax->list (syntax (clause ...)))]
                [clausel (map
                          (lambda (body clause)
                            (annotate-lambda
                             expr clause body phase))
                          (syntax->list (syntax (body ...)))
                          clauses)])
           (rearm
            expr
            (keep-lambda-properties
             expr
             (rebuild disarmed-expr (map cons clauses clausel))))))]
         
      ;; Wrap RHSs and body
      [(let-values ([vars rhs] ...) . body)
       (let ([rhsl (map (curryr (curry instrument-binding phase) #'let-values)
                        (syntax->list #'(vars ...))
                        (syntax->list #'(rhs ...)))]
             [bodysl (map (lambda (body) (cons body (annotate body phase))) (syntax->list #'body))])
         (rearm
          expr
          (rebuild disarmed-expr (append rhsl bodysl))))]
      [(letrec-values ([vars rhs] ...) . body)
       (let ([rhsl (map (curryr (curry instrument-binding phase) #'letrec-values)
                        (syntax->list #'(vars ...))
                        (syntax->list #'(rhs ...)))]
             [bodysl (map (lambda (body) (cons body (annotate body phase))) (syntax->list #'body))])
         (rearm
          expr
          (rebuild disarmed-expr (append rhsl bodysl))))]
      ;; This case is needed for `#lang errortrace ...', which uses
      ;; `local-expand' on the module body.
      [(letrec-syntaxes+values sbindings ([vars rhs] ...) . body)
       (let ([rhsl (map (curryr (curry instrument-binding phase) #'letrec-values)
                        (syntax->list #'(vars ...))
                        (syntax->list #'(rhs ...)))]
             [bodysl (map (lambda (body) (cons body (annotate body phase))) (syntax->list #'body))])
         (rearm
          expr
          (rebuild disarmed-expr (append rhsl bodysl))))]

      ;; Wrap RHS
      [(set! var rhs)
       (let ([new-rhs (annotate (syntax rhs) phase)])
         (rearm
          expr
          (rebuild disarmed-expr (list (cons #'rhs new-rhs)))))]
         
      ;; Wrap subexpressions only
      [(begin e)
       ;; Single expression: no mark
       (rearm
        expr
        #`(begin #,(annotate (syntax e) phase)))]
      [(begin . body)
       (rearm
        expr
        (annotate-seq disarmed-expr #'body annotate phase))]
      [(begin0 . body)
       (rearm
        expr
        (annotate-seq disarmed-expr #'body annotate phase))]
      [(if tst thn els)
       (let ([w-tst (annotate (syntax tst) phase)]
             [w-thn (annotate (syntax thn) phase)]
             [w-els (annotate (syntax els) phase)])
         (rearm
          expr
          (rebuild disarmed-expr (list (cons #'tst w-tst)
                                       (cons #'thn w-thn)
                                       (cons #'els w-els)))))]
      [(with-continuation-mark . body)
       (rearm
        expr
        (annotate-seq disarmed-expr (syntax body)
                      annotate phase))]
         
      ;; Wrap whole application, plus subexpressions
      [(#%plain-app . rest)
       (if (stx-null? (syntax rest))
           expr
           (let* ([head (car (syntax-e #'rest))]
                  [restl (map (lambda (body) (cons body (annotate body phase))) (syntax->list #'rest))])
             (rearm
              expr
              (rebuild
               (if (or (and (or (is-original? expr)
                                (is-original? head))
                            (should-instrument-path? (syntax-source head)))
                       (is-keyword-procedure-application? expr head))
                   (instrument-application expr #'rest phase)
                   disarmed-expr)
               restl))))]
      [_else
       (error 'errortrace "unrecognized expression form~a~a: ~.s"
              (if top? " at top-level" "")
              (if (zero? phase) "" (format " at phase ~a" phase))
              (syntax->datum expr))])))

;; Create two annotation procedures: one for top-level forms and one for everything else
(define annotate (make-annotate #f))
(define annotate-top (make-annotate #t))



;; Original syntax detection ---------------------------------------------------
;; This hack is copied from errortrace to detect "original" parts of the input
;; program.

;; Mark original syntax
(define annotate-key 'sympro:original)

;; Is this syntax original?
(define (is-original? stx)
  (and (syntax-source stx)
       (syntax-property stx annotate-key)))



;; Compile handler -------------------------------------------------------------

;; Annotate a top-level expr
(define (profile-annotate stx)
  (define annotate-id
    (syntax-case stx ()
      [(mod id lang (mod-begin forms ...))
       (and (id=? #'mod 'module)
            (or (id=? #'lang 'rosette) 
                (id=? #'lang 'rosette/safe)
                (not (symbolic-profile-rosette-only?)))
            (id=? #'mod-begin '#%module-begin))
       #'id]
      [_ #f]))
  (if annotate-id
      (let ()
        (printf "INSTRUMENTING ~v\n" (syntax-source stx))
        (set-add! original-files (syntax-source stx))
        (define expanded-e
          (expand-syntax ((make-add-annotate-property disarm annotate-key) stx)))
        (annotate-top expanded-e (namespace-base-phase)))
      stx))


;; Create a compile handler that invokes profile-annotate on
;; a piece of syntax that needs compilation, and then runs the
;; existing (current-compile)
(define (make-symbolic-profile-compile-handler)
  (define orig (current-compile))
  (lambda (e immediate-eval?)
    (orig (profile-annotate
           (if (syntax? e)
               e
               (namespace-syntax-introduce
                (datum->syntax #f e))))
          immediate-eval?)))


(define symbolic-profile-compile-handler
  (make-symbolic-profile-compile-handler))
