#lang racket

(require syntax/parse syntax/stx racket/keyword-transform
         (only-in "tool.rkt"
                  add-original-form!
                  record-apply!
                  restore-current-syntax!
                  add-current-syntax!)
         "../util/syntax.rkt")

(provide symbolic-trace-compile-handler
         symbolic-trace-rosette-only?)

;; This file implements trace instrumentation based on SymPro which, in turn, based on the `errortrace/stacktrace` library.
;;
;; The instrumentation is primarily for finding an expression to blame that leads to
;; an error. Because we operate on fully-expanded Racket core forms, we use
;; the origin property to find an original expression to blame. The principle is to
;; instrument any core form `e` which is a (top-level) result of an expansion from
;; a macro invocation `mac`, and evaluating `e` will result in an error.
;;
;; What this means, for instance, is that there's no need to instrument the
;; `#%plain-lambda` form, because suppose `mac` expands to `#%plain-lambda`, then
;; an error will not occur while evaluating `#%plain-lambda`, so `mac` will never
;; be blamed due to `#%plain-lambda`. Note that it's not true that `mac` will never
;; be blamed in general. Consider:
;;
;; ;; lib.rkt
;; #lang racket
;; (require rosette)
;; (provide mac)
;; (define-syntax-rule (mac) (begin (define (foo) (verify (1))) (foo)))
;;
;; ;; client.rkt
;; #lang rosette
;; (require "lib.rkt")
;; (mac)
;;
;; In this case, `mac` has two top-level forms that it expands to: `define-value`
;; and `#%plain-app`. While `mac` will not be blamed due to `define-value`, it is
;; blamed due to `#%app`.
;;
;; In a nutshell, we only need to instrument:
;; if, begin (expression context), begin0, let-values, letrec-values, set!,
;; with-continuation-mark, and #%plain-app.
;; Top-level forms like `module` or `define-values` won't evaluate to an error
;; as described above. Expressions like identifier, #%plain-lambda, and quote
;; won't evaluate to an error either.

;; If true (the default), we'll only instrument modules whose base language
;; is rosette or rosette/safe. Otherwise we'll instrument every module.
(define symbolic-trace-rosette-only? (make-parameter #t))

;; Misc syntax munging stuff ---------------------------------------------------

(define base-phase
  (variable-reference->module-base-phase (#%variable-reference)))
(define code-insp (variable-reference->module-declaration-inspector
                   (#%variable-reference)))

(define-disarm ~disarm code-insp)

(define-syntax-class lambda-clause
  (pattern (arg . body)))

(define (rearm orig new)
  (syntax-rearm new orig))

(define (disarm stx)
  (syntax-disarm stx code-insp))


;; Path management -------------------------------------------------------------

;; We shouldn't instrument procedure calls to Rosette functions
;; that aren't actually exported by Rosette
(define (should-instrument-path? path)
  (define the-path (path-string->string path))
  (or (not the-path)
      (not (or (string-contains? the-path "rosette/base/form/module.rkt")
               (string-contains? the-path "rosette/base/form/control.rkt")
               (string-contains? the-path "rosette/query/form.rkt")
               (string-contains? the-path "rosette/query/core.rkt")))))



;; Instrumentation for procedure applications ----------------------------------

;; This is a giant hack to detect applications of keyword procedures.
;; Macro expansion of the definition and application of a keyword procedure
;; hides the information we need, with no simple way to get it back
;; (the "is original?" syntax property we add below is not preserved).
;; So we have this heuristic to try to detect applications of keyword procedures
;; that originated in a file we're instrumenting.
(define original-files (mutable-set))
(define (is-keyword-procedure-application? expr head)
  ; Here are the rules:
  ; - if `head` has an alias or converted args property, it must be a kw procedure application.
  ;   return #t iff the source of that property is not in rosette/query/form.rkt.
  ; - otherwise, it's a kw procedure application if the source of the expr is kw.rkt.
  ;   - if `head` has a source, it must be an original file
  ;   - if `head` has no source, assume it's a kw procedure application unless it's the
  ;     `unpack` procedure generated by kw.rkt
  (define source-property
    (or (syntax-procedure-alias-property head)
        (syntax-procedure-converted-arguments-property head)))
  (cond
    [source-property
     (define src (syntax-source (if (pair? source-property) (car source-property) source-property)))
     (should-instrument-path? src)]
    [(and (syntax-source expr)
          (string-contains? (path-string->string (syntax-source expr))
                            "racket/private/kw.rkt"))
     (if (syntax-source head)
         (set-member? original-files (syntax-source head))
         (let ([s (syntax->datum head)])
           (or (not (symbol? s))
               (not (string-prefix? (symbol->string s) "unpack")))))]
    [else #f]))


;; Produce a list of syntax objects that quote each item in the input list
(define (quote-list lst phase)
  (with-syntax ([qt (syntax-shift-phase-level #'quote (- phase base-phase))])
    (for/list ([x lst]) (quasisyntax (qt #,x)))))


(define (instrument-application stx rest phase)
  (with-syntax ([app (syntax-shift-phase-level #'#%plain-app (- phase base-phase))]
                [qt (syntax-shift-phase-level #'quote (- phase base-phase))]
                [lst (syntax-shift-phase-level #'list (- phase base-phase))])
    #`(app (qt #,record-apply!) (app lst #,@(quote-list (syntax->readable-location stx) phase)) #,@rest)))

;; Core instrumentation procedure ----------------------------------------------

;; Recursively annotate a lambda expression
(define (annotate-lambda expr clause bodys-stx phase)
  (let* ([bodys (stx->list bodys-stx)]
         [bodyl (map (curryr annotate phase) bodys)])
    (rebuild clause (map cons bodys bodyl))))

;; Recursively annotate a submodule
(define (annotate-module expr disarmed-expr phase)
  (define shifted-disarmed-expr (syntax-shift-phase-level disarmed-expr (- phase)))
  (syntax-parse shifted-disarmed-expr
    #:literal-sets (kernel-literals)
    [(_ _name _init-import (~and mb (~disarm (#%plain-module-begin body ...))))
     ;; Just wrap body expressions
     (define bodys (attribute body))
     (define bodyl (map (curryr annotate-top 0) bodys))
     (rearm
      expr
      (syntax-shift-phase-level
       (rebuild shifted-disarmed-expr
                (list (cons #'mb (rearm #'mb (rebuild #'mb (map cons bodys bodyl))))))
       phase))]))

;; Create a top-level annotation procedure that recurses down the syntax of a
;; fully expanded module.
;; This form is copied from errortrace, with the features we don't use removed,
;; and with additional annotation for let bindings and top level define-values.
(define ((make-annotate top?) expr phase)
  (define disarmed-expr (disarm expr))
  (define instrument-track (make-instrument-track expr phase))
  (define transform (make-transform expr disarmed-expr annotate phase rearm))
  (syntax-parse disarmed-expr
      #:literal-sets ([kernel-literals #:phase phase])
      [_:identifier expr]
      [(#%top . id) expr]
      [(#%variable-reference . _) expr]

      [(define-values names rhs)
       #:when top?
       (transform (list #'rhs))]
      [(begin exprs ...)
       #:when top?
       (transform (attribute exprs) #:annotate annotate-top)]
      [(define-syntaxes (name ...) rhs)
       #:when top?
       (transform (list #'rhs) #:phase (add1 phase))]
      [(begin-for-syntax exprs ...)
       #:when top?
       (transform (attribute exprs) #:annotate annotate-top #:phase (add1 phase))]
      [(module _name _init-import _mb)
       (annotate-module expr disarmed-expr 0)]
      [(module* _name init-import _mb)
       (annotate-module expr disarmed-expr (if (syntax-e #'init-import) 0 phase))]
      [(#%expression e)
       (rearm expr #`(#%expression #,(annotate #'e phase)))]
      ;; No way to wrap
      [(#%require . _) expr]
      ;; No error possible (and no way to wrap)
      [(#%provide . _) expr]
      [(#%declare . _) expr]


      ;; Expressions --------------------------------------------------------------

      ;; No error possible
      [(quote _) expr]
      [(quote-syntax . _) expr]
      ;; Wrap body, also a profile point
      [(#%plain-lambda . clause:lambda-clause)
       (rearm expr
              (keep-lambda-properties
               expr
               (annotate-lambda expr disarmed-expr #'clause.body phase)))]
      [(case-lambda clause:lambda-clause ...)
       (define clauses (attribute clause))
       (define clausel (map (λ (body clause)
                              (annotate-lambda expr clause body phase))
                            (attribute clause.body)
                            clauses))
       (rearm
        expr
        (keep-lambda-properties
         expr
         (rebuild disarmed-expr (map cons clauses clausel))))]

      ;; Wrap RHSs and body
      [(let-values ([_vars rhs] ...) body ...)
       (instrument-track (transform (append (attribute rhs) (attribute body))))]

      [(letrec-values ([_vars rhs] ...) body ...)
       (instrument-track (transform (append (attribute rhs) (attribute body))))]

      ;; Wrap RHS
      [(set! _var rhs)
       (instrument-track (transform (list #'rhs)))]

      ;; Wrap subexpressions only; single expression: no mark
      [(begin e) (instrument-track (rearm expr #`(begin #,(annotate #'e phase))))]
      [(begin body ...)
       (instrument-track (transform (attribute body)))]
      [(begin0 body ...)
       (instrument-track (transform (attribute body)))]
      [(if tst thn els) (instrument-track (transform (list #'tst #'thn #'els)))]
      [(with-continuation-mark body ...)
       (instrument-track (transform (attribute body)))]

      ;; Wrap whole application, plus subexpressions
      [(#%plain-app) expr]
      [(#%plain-app head tail ...)
       (instrument-track
        (transform
         (cons #'head (attribute tail))
         #:expr
         (if (or (and (or (is-original? expr) (is-original? #'head))
                      (should-instrument-path? (syntax-source #'head)))
                 (is-keyword-procedure-application? expr #'head))
             (instrument-application expr #'(head tail ...) phase)
             disarmed-expr)))]
      [_ (error 'errortrace "unrecognized expression form~a~a: ~.s"
                (if top? " at top-level" "")
                (if (zero? phase) "" (format " at phase ~a" phase))
                (syntax->datum expr))]))

(define ((make-instrument-track expr phase) result-stx)
  (define (instrument id)
    (with-syntax ([qt (syntax-shift-phase-level #'quote (- phase base-phase))])
      #`(begin
          ((qt #,add-current-syntax!)
           (cons (qt #,(syntax->datum id))
                 (qt #,(syntax->readable-location id))))
          (call-with-exception-handler
           (qt #,restore-current-syntax!)
           (λ ()
             (begin0 #,result-stx
               ((qt #,restore-current-syntax!))))))))

  (define origin (syntax-property expr 'origin))
  (or (and origin
           (let find-origin ([origin origin])
             (for/or ([id-or-origin (in-list origin)])
               (cond
                 [(identifier? id-or-origin)
                  (and (set-member? original-files (syntax-source id-or-origin))
                       (instrument id-or-origin))]
                 [else (find-origin id-or-origin)]))))
      result-stx))

;; Create two annotation procedures: one for top-level forms and one for everything else
(define annotate (make-annotate #f))
(define annotate-top (make-annotate #t))

(define (collect-syntax s)
  (when (syntax? s)
    (syntax-parse (disarm s)
      [(head:id tail ...)
       (add-original-form! this-syntax this-syntax)
       (add-original-form! #'head this-syntax)
       (for ([s (in-list (attribute tail))])
         (collect-syntax s))]
      [(arg ...)
       (add-original-form! this-syntax this-syntax)
       (for ([s (in-list (attribute arg))])
         (collect-syntax s))]
      [_ (void)]))
  s)


;; Original syntax detection ---------------------------------------------------
;; This hack is copied from errortrace to detect "original" parts of the input
;; program.

;; Mark original syntax
(define annotate-key 'symtrace:original)
(define (add-annotate-property s)
  (cond
   [(syntax? s)
    (define new-s (syntax-rearm
                   (let ([s (disarm s)])
                     (datum->syntax s
                                    (add-annotate-property (syntax-e s))
                                    s
                                    s))
                   s))
    (syntax-property new-s annotate-key #t #t)]
   [(pair? s)
    (cons (add-annotate-property (car s))
          (add-annotate-property (cdr s)))]
   [(vector? s)
    (for/vector #:length (vector-length s) ([e (in-vector s)])
                (add-annotate-property e))]
   [(box? s) (box (add-annotate-property (unbox s)))]
   [(prefab-struct-key s)
    => (lambda (k)
         (apply make-prefab-struct
                k
                (add-annotate-property (cdr (vector->list (struct->vector s))))))]
   [(and (hash? s) (immutable? s))
    (cond
     [(hash-eq? s)
      (for/hasheq ([(k v) (in-hash s)])
        (values k (add-annotate-property v)))]
     [(hash-eqv? s)
      (for/hasheqv ([(k v) (in-hash s)])
        (values k (add-annotate-property v)))]
     [else
      (for/hash ([(k v) (in-hash s)])
        (values k (add-annotate-property v)))])]
   [else s]))

;; Is this syntax original?
(define (is-original? stx)
  (and (syntax-source stx)
       (syntax-property stx annotate-key)))

;; Compile handler -------------------------------------------------------------

(define (ok-lang? lang)
  (or (not (symbolic-trace-rosette-only?))
      (member lang '(rosette rosette/safe))))

;; Annotate a top-level expr
(define trace-annotate
  (syntax-parser
    [(_module _mod-id lang _module-begin)
     #:when (ok-lang? (syntax-e #'lang))
     (printf "INSTRUMENTING ~v\n" (syntax-source this-syntax))
     (set-add! original-files (syntax-source this-syntax))
     (define expanded-e (expand-syntax
                         (collect-syntax
                          (add-annotate-property this-syntax))))
     (annotate-top expanded-e (namespace-base-phase))]
    [_ this-syntax]))


;; Create a compile handler that invokes trace-annotate on
;; a piece of syntax that needs compilation, and then runs the
;; existing (current-compile)
(define (make-symbolic-trace-compile-handler)
  (define orig (current-compile))
  (lambda (e immediate-eval?)
    (orig (trace-annotate
           (if (syntax? e)
               e
               (namespace-syntax-introduce
                (datum->syntax #f e))))
          immediate-eval?)))


(define symbolic-trace-compile-handler
  (make-symbolic-trace-compile-handler))
