#lang racket

(require syntax/parse racket/keyword-transform
         (only-in "tool.rkt" add-original-form!)
         "../util/syntax.rkt")

(provide symbolic-trace-compile-handler
         symbolic-trace-rosette-only?)

;; This file implements trace instrumentation based on SymPro which, in turn, based on the `errortrace/stacktrace` library.
;;
;; The instrumentation is primarily for finding an expression to blame that leads to
;; an error. Because we operate on fully-expanded Racket core forms, we use
;; the origin property to find an original expression to blame. The principle is to
;; instrument any core form `e` whose evaluation could result in an error.
;;
;; What this means, for instance, is that there's no need to instrument the
;; `#%plain-lambda` form.
;;
;; In a nutshell, we only need to instrument:
;; if, begin (expression context), begin0, let-values, letrec-values, set!,
;; with-continuation-mark, #%plain-app, and `define-values`.
;; Top-level forms like `module` and `#%require` won't evaluate to an error
;; as described above. Expressions like identifier, #%plain-lambda, and quote
;; won't evaluate to an error either.

;; If true (the default), we'll only instrument modules whose base language
;; is rosette or rosette/safe. Otherwise we'll instrument every module.
(define symbolic-trace-rosette-only? (make-parameter #t))

;; Misc syntax munging stuff ---------------------------------------------------

(define code-insp (variable-reference->module-declaration-inspector
                   (#%variable-reference)))

(define-disarm ~disarm code-insp)

(define (rearm orig new)
  (syntax-rearm new orig))

(define (disarm stx)
  (syntax-disarm stx code-insp))

;; Path management -------------------------------------------------------------

;; We shouldn't instrument procedure calls to Rosette functions
;; that aren't actually exported by Rosette
(define (should-instrument-path? path)
  (define the-path (path-string->string path))
  (or (not the-path)
      (not (or (string-contains? the-path "rosette/base/form/module.rkt")
               (string-contains? the-path "rosette/base/form/control.rkt")
               (string-contains? the-path "rosette/base/core/bool.rkt")
               (string-contains? the-path "rosette/query/form.rkt")
               (string-contains? the-path "rosette/query/core.rkt")))))



;; Instrumentation for procedure applications ----------------------------------

;; This is a giant hack to detect applications of keyword procedures.
;; Macro expansion of the definition and application of a keyword procedure
;; hides the information we need, with no simple way to get it back
;; (the "is original?" syntax property we add below is not preserved).
;; So we have this heuristic to try to detect applications of keyword procedures
;; that originated in a file we're instrumenting.
(define original-files (mutable-set))
(define (is-keyword-procedure-application? expr head)
  ; Here are the rules:
  ; - if `head` has an alias or converted args property, it must be a kw procedure application.
  ;   return #t iff the source of that property is not in rosette/query/form.rkt.
  ; - otherwise, it's a kw procedure application if the source of the expr is kw.rkt.
  ;   - if `head` has a source, it must be an original file
  ;   - if `head` has no source, assume it's a kw procedure application unless it's the
  ;     `unpack` procedure generated by kw.rkt
  (define source-property
    (or (syntax-procedure-alias-property head)
        (syntax-procedure-converted-arguments-property head)))
  (cond
    [source-property
     (define src (syntax-source (if (pair? source-property) (car source-property) source-property)))
     (should-instrument-path? src)]
    [(and (syntax-source expr)
          (string-contains? (path-string->string (syntax-source expr))
                            "racket/private/kw.rkt"))
     (if (syntax-source head)
         (set-member? original-files (syntax-source head))
         (let ([s (syntax->datum head)])
           (or (not (symbol? s))
               (not (string-prefix? (symbol->string s) "unpack")))))]
    [else #f]))


;; Core instrumentation procedure ----------------------------------------------

;; Recursively annotate a submodule
(define (annotate-module expr disarmed-expr phase)
  (define shifted-disarmed-expr (syntax-shift-phase-level disarmed-expr (- phase)))
  (syntax-parse shifted-disarmed-expr
    #:literal-sets (kernel-literals)
    [(_ _name _init-import (~and mb (~disarm (#%plain-module-begin body ...))))
     ;; Just wrap body expressions
     (define bodys (attribute body))
     (define bodyl (map (curryr annotate-top 0) bodys))
     (rearm
      expr
      (syntax-shift-phase-level
       (rebuild shifted-disarmed-expr
                (list (cons #'mb (rearm #'mb (rebuild #'mb (map cons bodys bodyl))))))
       phase))]))

(define (make-certification body)
  #`(call-with-immediate-continuation-mark
     'symbolic-trace:stack-key
     (λ (k)
       (with-continuation-mark
         'symbolic-trace:stack-key
         (and k (list 'certified (#,second k) (#,third k)))
         (let () #,@body)))))

;; Create a top-level annotation procedure that recurses down the syntax of a
;; fully expanded module.
;; This form is copied from errortrace, with the features we don't use removed,
;; and with additional annotation for let bindings and top level define-values.
(define ((make-annotate top?) expr phase)
  (define disarmed-expr (disarm expr))
  (define instrument-track (make-instrument-track expr phase))
  (define transform (make-transform expr disarmed-expr annotate phase rearm))
  (syntax-parse disarmed-expr
    #:literal-sets ([kernel-literals #:phase phase])
    [_:identifier expr]
    [(#%top . _id) expr]
    [(#%variable-reference . _) expr]

    [(define-values _names rhs)
     #:when top?
     (instrument-track (transform (list #'rhs)))]
    [(begin exprs ...)
     #:when top?
     (transform (attribute exprs) #:annotate annotate-top)]
    [(define-syntaxes (_name ...) rhs)
     #:when top?
     (transform (list #'rhs) #:phase (add1 phase))]
    [(begin-for-syntax exprs ...)
     #:when top?
     (transform (attribute exprs) #:annotate annotate-top #:phase (add1 phase))]
    [(module _name _init-import _mb)
     (annotate-module expr disarmed-expr 0)]
    [(module* _name init-import _mb)
     (annotate-module expr disarmed-expr (if (syntax-e #'init-import) 0 phase))]
    [(#%expression e)
     (rearm expr #`(#%expression #,(annotate #'e phase)))]
    ;; No way to wrap
    [(#%require . _) expr]
    ;; No error possible (and no way to wrap)
    [(#%provide . _) expr]
    [(#%declare . _) expr]


    ;; Expressions --------------------------------------------------------------

    ;; No error possible
    [(quote _) expr]
    [(quote-syntax . _) expr]
    ;; Wrap body, also a profile point
    [(#%plain-lambda _ids body ...)
     #:with {~and stx (p-a ids-2 body-2 ...)} (disarm (transform (attribute body)))
     (rearm
      expr
      (keep-lambda-properties
       expr
       (datum->syntax #'stx
                      (list #'p-a #'ids-2 (make-certification (attribute body-2)))
                      #'stx
                      #'stx)))]
    [(case-lambda [_ids body ...] ...)
     #:with {~and stx (c-l [ids-2 body-2 ...] ...)} (disarm (transform (append* (attribute body))))
     (rearm
      expr
      (keep-lambda-properties
       expr
       (datum->syntax #'stx
                      (cons #'c-l
                            (for/list ([clause-ids (in-list (attribute ids-2))]
                                       [clause-body (in-list (attribute body-2))])
                              (list clause-ids
                                    (make-certification clause-body)))))))]

    ;; Wrap RHSs and body
    [(let-values ([_vars rhs] ...) body ...)
     (instrument-track (transform (append (attribute rhs) (attribute body))))]

    [(letrec-values ([_vars rhs] ...) body ...)
     (instrument-track (transform (append (attribute rhs) (attribute body))))]

    ;; Wrap RHS
    [(set! _var rhs)
     (instrument-track (transform (list #'rhs)))]

    ;; Wrap subexpressions only; single expression: no mark
    [(begin e) (instrument-track (rearm expr #`(begin #,(annotate #'e phase))))]
    [(begin body ...)
     (instrument-track (transform (attribute body)))]
    [(begin0 body ...)
     (instrument-track (transform (attribute body)))]
    [(if tst thn els) (instrument-track (transform (list #'tst #'thn #'els)))]
    [(with-continuation-mark body ...)
     (instrument-track (transform (attribute body)))]

    ;; Wrap whole application, plus subexpressions
    [(#%plain-app) expr]
    [(#%plain-app head tail ...)
     #:when (or (and (or (is-original? expr) (is-original? #'head))
                     (should-instrument-path? (syntax-source #'head)))
                (is-keyword-procedure-application? expr #'head))
     #:with {~and stx (p-a head-2 tail-2 ...)}
     (disarm (transform (cons #'head (attribute tail))))

     (instrument-track
      #`(let ([the-function head-2])
          (call-with-immediate-continuation-mark
           'symbolic-trace:stack-key
           (λ (k)
             (with-continuation-mark
               'symbolic-trace:stack-key
               (let ([entry (cons the-function '#,(syntax->readable-location #'stx))])
                 (if k
                     (list 'certified (#,second k) entry)
                     (list 'uncertified entry entry)))
               #,(datum->syntax #'stx
                                (append (list #'p-a #'the-function)
                                        (attribute tail-2))
                                #'stx
                                #'stx))))))]

    [(#%plain-app head tail ...)
     (instrument-track (transform (cons #'head (attribute tail))))]

    [_ (error 'errortrace "unrecognized expression form~a~a: ~.s"
              (if top? " at top-level" "")
              (if (zero? phase) "" (format " at phase ~a" phase))
              (syntax->datum expr))]))

(define (find-origin expr)
  (define (loop origin)
    (cond
      [(identifier? origin)
       (and (set-member? original-files (syntax-source origin)) origin)]
      [(pair? origin)
       (or (loop (car origin)) (loop (cdr origin)))]
      [else #f]))
  (or (syntax-parse expr
        [(x:id . _) (loop #'x)]
        [_ #f])
      (loop (syntax-property expr 'origin))))

(define ((make-instrument-track expr phase) result-stx)
  (define id (find-origin expr))
  (cond
    [id
     (define (get-template v)
       #`(with-continuation-mark
           'symbolic-trace:stx-key
           (cons '#,(syntax->datum id)
                 '#,(syntax->readable-location id))
           #,v))
     (syntax-parse (disarm result-stx)
       #:literal-sets ([kernel-literals #:phase phase])
       [({~and d-v define-values} {~and ids (id)} e)
        (datum->syntax this-syntax
                       (list #'d-v
                             #'ids
                             (get-template
                              (syntax-property #'e
                                               'inferred-name
                                               (or (syntax-property #'e 'inferred-name)
                                                   (syntax-e #'id)))))
                       this-syntax
                       this-syntax)]
       [({~and d-v define-values} ids e)
        (datum->syntax this-syntax
                       (list #'d-v
                             #'ids
                             (get-template #'e))
                       this-syntax
                       this-syntax)]
       [_ (get-template result-stx)])]
    [else result-stx]))

;; Create two annotation procedures: one for top-level forms and one for everything else
(define annotate (make-annotate #f))
(define annotate-top (make-annotate #t))

(define (collect-syntax s)
  (when (syntax? s)
    (syntax-parse (disarm s)
      [(head:id tail ...)
       (add-original-form! this-syntax this-syntax)
       (add-original-form! #'head this-syntax)
       (for ([s (in-list (attribute tail))])
         (collect-syntax s))]
      [(arg ...)
       (add-original-form! this-syntax this-syntax)
       (for ([s (in-list (attribute arg))])
         (collect-syntax s))]
      [_ (void)]))
  s)


;; Original syntax detection ---------------------------------------------------
;; This hack is copied from errortrace to detect "original" parts of the input
;; program.

;; Mark original syntax
(define annotate-key 'symtrace:original)
(define (add-annotate-property s)
  (cond
   [(syntax? s)
    (define new-s (syntax-rearm
                   (let ([s (disarm s)])
                     (datum->syntax s
                                    (add-annotate-property (syntax-e s))
                                    s
                                    s))
                   s))
    (syntax-property new-s annotate-key #t #t)]
   [(pair? s)
    (cons (add-annotate-property (car s))
          (add-annotate-property (cdr s)))]
   [(vector? s)
    (for/vector #:length (vector-length s) ([e (in-vector s)])
                (add-annotate-property e))]
   [(box? s) (box (add-annotate-property (unbox s)))]
   [(prefab-struct-key s)
    => (lambda (k)
         (apply make-prefab-struct
                k
                (add-annotate-property (cdr (vector->list (struct->vector s))))))]
   [(and (hash? s) (immutable? s))
    (cond
     [(hash-eq? s)
      (for/hasheq ([(k v) (in-hash s)])
        (values k (add-annotate-property v)))]
     [(hash-eqv? s)
      (for/hasheqv ([(k v) (in-hash s)])
        (values k (add-annotate-property v)))]
     [else
      (for/hash ([(k v) (in-hash s)])
        (values k (add-annotate-property v)))])]
   [else s]))

;; Is this syntax original?
(define (is-original? stx)
  (and (syntax-source stx)
       (syntax-property stx annotate-key)))

;; Compile handler -------------------------------------------------------------

(define (ok-lang? lang)
  (or (not (symbolic-trace-rosette-only?))
      (member lang '(rosette rosette/safe))))

;; Annotate a top-level expr
(define trace-annotate
  (syntax-parser
    [(mod:id _mod-id lang _module-begin)
     #:when (and (free-identifier=? #'mod
                                    (namespace-module-identifier)
                                    (namespace-base-phase))
                 (ok-lang? (syntax-e #'lang)))
     (printf "INSTRUMENTING ~v\n" (syntax-source this-syntax))
     (set-add! original-files (syntax-source this-syntax))
     (define expanded-e (expand-syntax
                         (collect-syntax
                          (add-annotate-property this-syntax))))
     (annotate-top expanded-e (namespace-base-phase))]
    [_ this-syntax]))

;; Create a compile handler that invokes trace-annotate on
;; a piece of syntax that needs compilation, and then runs the
;; existing (current-compile)
(define (make-symbolic-trace-compile-handler)
  (define orig (current-compile))
  (lambda (e immediate-eval?)
    (orig (trace-annotate
           (if (syntax? e)
               e
               (namespace-syntax-introduce
                (datum->syntax #f e))))
          immediate-eval?)))


(define symbolic-trace-compile-handler
  (make-symbolic-trace-compile-handler))
